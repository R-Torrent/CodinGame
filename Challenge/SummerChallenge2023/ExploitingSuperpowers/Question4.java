package Challenge.SummerChallenge2023.ExploitingSuperpowers;

import java.util.*;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;

public class Question4 {

    /**
     * @param instructions The list of instructions as memorized by the mutant.
     * @param target The coordinates (x, y) of the target.
     * @return A string respecting the given format to fix the mutant's path.
     */
    public static String findCorrectPath(List<String> instructions, List<Integer> target) {
        // Write your code here
        List<Movement> instructions2 = instructions.stream().map(Movement::transform).toList();

        for (int i = 0; i < instructions2.size(); i++) {
            List<Movement> newInstructions = new ArrayList<>(instructions2);
            for (Movement newInstruction : instructions2.get(i).otherMovements()) {
                newInstructions.set(i, newInstruction);
                if (runSimulation(newInstructions, target.get(0), target.get(1)))
                    return "Replace instruction " + ++i + " with " + newInstruction.string;
            }
        }

        return "";
    }

    enum Movement {

        FORWARD   ("FORWARD") {
            List<Movement> otherMovements() { return List.of(BACK, TURN_LEFT, TURN_RIGHT); }
        },
        BACK      ("BACK") {
            List<Movement> otherMovements() { return List.of(FORWARD, TURN_LEFT, TURN_RIGHT); }
        },
        TURN_LEFT ("TURN LEFT") {
            List<Movement> otherMovements() { return List.of(FORWARD, BACK, TURN_RIGHT); }
        },
        TURN_RIGHT ("TURN RIGHT") {
            List<Movement> otherMovements() { return List.of(FORWARD, BACK, TURN_LEFT); }
        };

        private final String string;

        Movement (String string) { this.string = string; }

        abstract List<Movement> otherMovements();

        static Movement transform(String name) {
            switch (name) {
                default :
                case "FORWARD"    : return FORWARD;
                case "BACK"       : return BACK;
                case "TURN LEFT"  : return TURN_LEFT;
                case "TURN RIGHT" : return TURN_RIGHT;
            }
        }

    }

    private static boolean runSimulation(List<Movement> instructions, int xt, int yt) {

        enum Dir {

            RIGHT {
                Dir next(Movement m, int[] pos) {
                    switch (m) {
                        default :
                        case FORWARD    : pos[0]++; return RIGHT;
                        case BACK       : pos[0]--; return RIGHT;
                        case TURN_LEFT  : return UP;
                        case TURN_RIGHT : return DOWN;
                    }
                }
            },
            LEFT {
                Dir next(Movement m, int[] pos) {
                    switch (m) {
                        default :
                        case FORWARD    : pos[0]--; return LEFT;
                        case BACK       : pos[0]++; return LEFT;
                        case TURN_LEFT  : return DOWN;
                        case TURN_RIGHT : return UP;
                    }
                }
            },
            UP {
                Dir next(Movement m, int[] pos) {
                    switch (m) {
                        default :
                        case FORWARD    : pos[1]++; return UP;
                        case BACK       : pos[1]--; return UP;
                        case TURN_LEFT  : return LEFT;
                        case TURN_RIGHT : return RIGHT;
                    }
                }
            },
            DOWN {
                Dir next(Movement m, int[] pos) {
                    switch (m) {
                        default :
                        case FORWARD    : pos[1]--; return DOWN;
                        case BACK       : pos[1]++; return DOWN;
                        case TURN_LEFT  : return RIGHT;
                        case TURN_RIGHT : return LEFT;
                    }
                }
            };

            abstract Dir next(Movement m, int[] pos);

        }

        int[] p = new int[2];
        Dir d = Dir.RIGHT;

        for (Movement m : instructions)
            d = d.next(m, p);

        return p[0] == xt && p[1] == yt;
    }

    /* Ignore and do not change the code below */
    private static final Gson gson = new GsonBuilder().disableHtmlEscaping().create();

    /**
     * Try a solution
     * @param recipe A string respecting the given format to fix the mutant's path.
     */
    public static void trySolution(String recipe) {
        System.out.println("" + gson.toJson(recipe));
    }

    public static void main(String args[]) {
        try (Scanner in = new Scanner(System.in)) {
            trySolution(findCorrectPath(
                    gson.fromJson(in.nextLine(), new TypeToken<List<String>>(){}.getType()),
                    gson.fromJson(in.nextLine(), new TypeToken<List<Integer>>(){}.getType())
            ));
        }
    }
    /* Ignore and do not change the code above */

}