package Challenge.SummerChallenge2023.ExploitingSuperpowers;

import java.util.*;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;

public class Question8 {

    /**
     * @param instructions The compressed instructions as memorized by the mutant.
     * @param target The coordinates (x, y) of the target.
     * @param obstacles An array containing all (x, y) coordinates of obstacles.
     * @return A string respecting the given format to fix the mutant's path.
     */
    public static String findCorrectPath(String instructions, List<Integer> target, List<List<Integer>> obstacles) {
        // Write your code here
        List<Movement> instructions2 = instructions.chars().mapToObj(Movement::transform).toList();

        for (int i = 0; i < instructions2.size(); i++) {
            List<Movement> newInstructions = new ArrayList<>(instructions2);
            for (Movement newInstruction : instructions2.get(i).otherMovements()) {
                newInstructions.set(i, newInstruction);
                if (runSimulation(newInstructions, target.get(0), target.get(1), obstacles))
                    return "Replace instruction " + ++i + " with " + newInstruction.string;
            }
        }

        return "";
    }

    enum Movement {

        FORWARD   ("FORWARD") {
            List<Movement> otherMovements() { return List.of(BACK, TURN_LEFT, TURN_RIGHT); }
        },
        BACK      ("BACK") {
            List<Movement> otherMovements() { return List.of(FORWARD, TURN_LEFT, TURN_RIGHT); }
        },
        TURN_LEFT ("TURN LEFT") {
            List<Movement> otherMovements() { return List.of(FORWARD, BACK, TURN_RIGHT); }
        },
        TURN_RIGHT ("TURN RIGHT") {
            List<Movement> otherMovements() { return List.of(FORWARD, BACK, TURN_LEFT); }
        };

        private final String string;

        Movement (String string) { this.string = string; }

        abstract List<Movement> otherMovements();

        static Movement transform(int intValue) {
            switch ((char)intValue) {
                default  :
                case 'F' : return FORWARD;
                case 'B' : return BACK;
                case 'L' : return TURN_LEFT;
                case 'R' : return TURN_RIGHT;
            }
        }

    }

    private static int distanceToTarget(int xp, int yp, int xt, int yt)
    {
        return Math.abs(xt - xp) + Math.abs(yt - yp);
    }

    private static boolean runSimulation(List<Movement> instructions, int xt, int yt, List<List<Integer>> obstacles) {

        enum Dir {

            RIGHT {
                Dir next(Movement m, int[] pos) {
                    switch (m) {
                        default :
                        case FORWARD    : pos[0]++; return RIGHT;
                        case BACK       : pos[0]--; return RIGHT;
                        case TURN_LEFT  : return UP;
                        case TURN_RIGHT : return DOWN;
                    }
                }
            },
            LEFT {
                Dir next(Movement m, int[] pos) {
                    switch (m) {
                        default :
                        case FORWARD    : pos[0]--; return LEFT;
                        case BACK       : pos[0]++; return LEFT;
                        case TURN_LEFT  : return DOWN;
                        case TURN_RIGHT : return UP;
                    }
                }
            },
            UP {
                Dir next(Movement m, int[] pos) {
                    switch (m) {
                        default :
                        case FORWARD    : pos[1]++; return UP;
                        case BACK       : pos[1]--; return UP;
                        case TURN_LEFT  : return LEFT;
                        case TURN_RIGHT : return RIGHT;
                    }
                }
            },
            DOWN {
                Dir next(Movement m, int[] pos) {
                    switch (m) {
                        default :
                        case FORWARD    : pos[1]--; return DOWN;
                        case BACK       : pos[1]++; return DOWN;
                        case TURN_LEFT  : return RIGHT;
                        case TURN_RIGHT : return LEFT;
                    }
                }
            };

            abstract Dir next(Movement m, int[] pos);

        }

        int[] p = new int[2];
        Dir d = Dir.RIGHT;

        int numInstructions = instructions.size();
        for (Movement m : instructions) {
            d = d.next(m, p);
            if (distanceToTarget(p[0], p[1], xt, yt) > --numInstructions  || obstacles.contains(List.of(p[0], p[1])))
                return false;
        }

        return p[0] == xt && p[1] == yt;
    }

    /* Ignore and do not change the code below */
    private static final Gson gson = new GsonBuilder().disableHtmlEscaping().create();

    /**
     * Try a solution
     * @param recipe A string respecting the given format to fix the mutant's path.
     */
    public static void trySolution(String recipe) {
        System.out.println("" + gson.toJson(recipe));
    }

    public static void main(String args[]) {
        try (Scanner in = new Scanner(System.in)) {
            trySolution(findCorrectPath(
                    gson.fromJson(in.nextLine(), new TypeToken<String>(){}.getType()),
                    gson.fromJson(in.nextLine(), new TypeToken<List<Integer>>(){}.getType()),
                    gson.fromJson(in.nextLine(), new TypeToken<List<List<Integer>>>(){}.getType())
            ));
        }
    }
    /* Ignore and do not change the code above */

}